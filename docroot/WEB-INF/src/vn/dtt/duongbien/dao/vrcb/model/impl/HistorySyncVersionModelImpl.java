/**
 * Copyright (c) 2000-2013 Liferay, Inc. All rights reserved.
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation; either version 2.1 of the License, or (at your option)
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 */

package vn.dtt.duongbien.dao.vrcb.model.impl;

import com.liferay.portal.kernel.bean.AutoEscapeBeanHandler;
import com.liferay.portal.kernel.util.GetterUtil;
import com.liferay.portal.kernel.util.ProxyUtil;
import com.liferay.portal.kernel.util.StringBundler;
import com.liferay.portal.kernel.util.StringPool;
import com.liferay.portal.model.CacheModel;
import com.liferay.portal.model.impl.BaseModelImpl;
import com.liferay.portal.service.ServiceContext;

import com.liferay.portlet.expando.model.ExpandoBridge;
import com.liferay.portlet.expando.util.ExpandoBridgeFactoryUtil;

import vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion;
import vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersionModel;

import java.io.Serializable;

import java.sql.Types;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * The base model implementation for the HistorySyncVersion service. Represents a row in the &quot;history_sync_version&quot; database table, with each column mapped to a property of this class.
 *
 * <p>
 * This implementation and its corresponding interface {@link vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersionModel} exist only as a container for the default property accessors generated by ServiceBuilder. Helper methods and all application logic should be put in {@link HistorySyncVersionImpl}.
 * </p>
 *
 * @author longdm
 * @see HistorySyncVersionImpl
 * @see vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion
 * @see vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersionModel
 * @generated
 */
public class HistorySyncVersionModelImpl extends BaseModelImpl<HistorySyncVersion>
	implements HistorySyncVersionModel {
	/*
	 * NOTE FOR DEVELOPERS:
	 *
	 * Never modify or reference this class directly. All methods that expect a history sync version model instance should use the {@link vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion} interface instead.
	 */
	public static final String TABLE_NAME = "history_sync_version";
	public static final Object[][] TABLE_COLUMNS = {
			{ "id", Types.BIGINT },
			{ "requesteddate", Types.TIMESTAMP },
			{ "timeofpublish", Types.TIMESTAMP },
			{ "categoryid", Types.VARCHAR },
			{ "syncunit", Types.VARCHAR },
			{ "syncuser", Types.VARCHAR },
			{ "syncversion", Types.VARCHAR },
			{ "latestvaluedate", Types.TIMESTAMP }
		};
	public static final String TABLE_SQL_CREATE = "create table history_sync_version (id LONG not null primary key,requesteddate DATE null,timeofpublish DATE null,categoryid VARCHAR(75) null,syncunit VARCHAR(75) null,syncuser VARCHAR(75) null,syncversion VARCHAR(75) null,latestvaluedate DATE null)";
	public static final String TABLE_SQL_DROP = "drop table history_sync_version";
	public static final String ORDER_BY_JPQL = " ORDER BY historySyncVersion.id ASC";
	public static final String ORDER_BY_SQL = " ORDER BY history_sync_version.id ASC";
	public static final String DATA_SOURCE = "vaoracangbienDataSource";
	public static final String SESSION_FACTORY = "liferaySessionFactory";
	public static final String TX_MANAGER = "liferayTransactionManager";
	public static final boolean ENTITY_CACHE_ENABLED = GetterUtil.getBoolean(com.liferay.util.service.ServiceProps.get(
				"value.object.entity.cache.enabled.vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion"),
			false);
	public static final boolean FINDER_CACHE_ENABLED = GetterUtil.getBoolean(com.liferay.util.service.ServiceProps.get(
				"value.object.finder.cache.enabled.vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion"),
			false);
	public static final boolean COLUMN_BITMASK_ENABLED = GetterUtil.getBoolean(com.liferay.util.service.ServiceProps.get(
				"value.object.column.bitmask.enabled.vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion"),
			true);
	public static long SYNCVERSION_COLUMN_BITMASK = 1L;
	public static long ID_COLUMN_BITMASK = 2L;
	public static final long LOCK_EXPIRATION_TIME = GetterUtil.getLong(com.liferay.util.service.ServiceProps.get(
				"lock.expiration.time.vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion"));

	public HistorySyncVersionModelImpl() {
	}

	@Override
	public long getPrimaryKey() {
		return _id;
	}

	@Override
	public void setPrimaryKey(long primaryKey) {
		setId(primaryKey);
	}

	@Override
	public Serializable getPrimaryKeyObj() {
		return _id;
	}

	@Override
	public void setPrimaryKeyObj(Serializable primaryKeyObj) {
		setPrimaryKey(((Long)primaryKeyObj).longValue());
	}

	@Override
	public Class<?> getModelClass() {
		return HistorySyncVersion.class;
	}

	@Override
	public String getModelClassName() {
		return HistorySyncVersion.class.getName();
	}

	@Override
	public Map<String, Object> getModelAttributes() {
		Map<String, Object> attributes = new HashMap<String, Object>();

		attributes.put("id", getId());
		attributes.put("requestedDate", getRequestedDate());
		attributes.put("timeofPublish", getTimeofPublish());
		attributes.put("categoryID", getCategoryID());
		attributes.put("syncUnit", getSyncUnit());
		attributes.put("syncUser", getSyncUser());
		attributes.put("syncVersion", getSyncVersion());
		attributes.put("latestValueDate", getLatestValueDate());

		return attributes;
	}

	@Override
	public void setModelAttributes(Map<String, Object> attributes) {
		Long id = (Long)attributes.get("id");

		if (id != null) {
			setId(id);
		}

		Date requestedDate = (Date)attributes.get("requestedDate");

		if (requestedDate != null) {
			setRequestedDate(requestedDate);
		}

		Date timeofPublish = (Date)attributes.get("timeofPublish");

		if (timeofPublish != null) {
			setTimeofPublish(timeofPublish);
		}

		String categoryID = (String)attributes.get("categoryID");

		if (categoryID != null) {
			setCategoryID(categoryID);
		}

		String syncUnit = (String)attributes.get("syncUnit");

		if (syncUnit != null) {
			setSyncUnit(syncUnit);
		}

		String syncUser = (String)attributes.get("syncUser");

		if (syncUser != null) {
			setSyncUser(syncUser);
		}

		String syncVersion = (String)attributes.get("syncVersion");

		if (syncVersion != null) {
			setSyncVersion(syncVersion);
		}

		Date latestValueDate = (Date)attributes.get("latestValueDate");

		if (latestValueDate != null) {
			setLatestValueDate(latestValueDate);
		}
	}

	@Override
	public long getId() {
		return _id;
	}

	@Override
	public void setId(long id) {
		_columnBitmask = -1L;

		_id = id;
	}

	@Override
	public Date getRequestedDate() {
		return _requestedDate;
	}

	@Override
	public void setRequestedDate(Date requestedDate) {
		_requestedDate = requestedDate;
	}

	@Override
	public Date getTimeofPublish() {
		return _timeofPublish;
	}

	@Override
	public void setTimeofPublish(Date timeofPublish) {
		_timeofPublish = timeofPublish;
	}

	@Override
	public String getCategoryID() {
		if (_categoryID == null) {
			return StringPool.BLANK;
		}
		else {
			return _categoryID;
		}
	}

	@Override
	public void setCategoryID(String categoryID) {
		_categoryID = categoryID;
	}

	@Override
	public String getSyncUnit() {
		if (_syncUnit == null) {
			return StringPool.BLANK;
		}
		else {
			return _syncUnit;
		}
	}

	@Override
	public void setSyncUnit(String syncUnit) {
		_syncUnit = syncUnit;
	}

	@Override
	public String getSyncUser() {
		if (_syncUser == null) {
			return StringPool.BLANK;
		}
		else {
			return _syncUser;
		}
	}

	@Override
	public void setSyncUser(String syncUser) {
		_syncUser = syncUser;
	}

	@Override
	public String getSyncVersion() {
		if (_syncVersion == null) {
			return StringPool.BLANK;
		}
		else {
			return _syncVersion;
		}
	}

	@Override
	public void setSyncVersion(String syncVersion) {
		_columnBitmask |= SYNCVERSION_COLUMN_BITMASK;

		if (_originalSyncVersion == null) {
			_originalSyncVersion = _syncVersion;
		}

		_syncVersion = syncVersion;
	}

	public String getOriginalSyncVersion() {
		return GetterUtil.getString(_originalSyncVersion);
	}

	@Override
	public Date getLatestValueDate() {
		return _latestValueDate;
	}

	@Override
	public void setLatestValueDate(Date latestValueDate) {
		_latestValueDate = latestValueDate;
	}

	public long getColumnBitmask() {
		return _columnBitmask;
	}

	@Override
	public ExpandoBridge getExpandoBridge() {
		return ExpandoBridgeFactoryUtil.getExpandoBridge(0,
			HistorySyncVersion.class.getName(), getPrimaryKey());
	}

	@Override
	public void setExpandoBridgeAttributes(ServiceContext serviceContext) {
		ExpandoBridge expandoBridge = getExpandoBridge();

		expandoBridge.setAttributes(serviceContext);
	}

	@Override
	public HistorySyncVersion toEscapedModel() {
		if (_escapedModel == null) {
			_escapedModel = (HistorySyncVersion)ProxyUtil.newProxyInstance(_classLoader,
					_escapedModelInterfaces, new AutoEscapeBeanHandler(this));
		}

		return _escapedModel;
	}

	@Override
	public Object clone() {
		HistorySyncVersionImpl historySyncVersionImpl = new HistorySyncVersionImpl();

		historySyncVersionImpl.setId(getId());
		historySyncVersionImpl.setRequestedDate(getRequestedDate());
		historySyncVersionImpl.setTimeofPublish(getTimeofPublish());
		historySyncVersionImpl.setCategoryID(getCategoryID());
		historySyncVersionImpl.setSyncUnit(getSyncUnit());
		historySyncVersionImpl.setSyncUser(getSyncUser());
		historySyncVersionImpl.setSyncVersion(getSyncVersion());
		historySyncVersionImpl.setLatestValueDate(getLatestValueDate());

		historySyncVersionImpl.resetOriginalValues();

		return historySyncVersionImpl;
	}

	@Override
	public int compareTo(HistorySyncVersion historySyncVersion) {
		int value = 0;

		if (getId() < historySyncVersion.getId()) {
			value = -1;
		}
		else if (getId() > historySyncVersion.getId()) {
			value = 1;
		}
		else {
			value = 0;
		}

		if (value != 0) {
			return value;
		}

		return 0;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}

		if (!(obj instanceof HistorySyncVersion)) {
			return false;
		}

		HistorySyncVersion historySyncVersion = (HistorySyncVersion)obj;

		long primaryKey = historySyncVersion.getPrimaryKey();

		if (getPrimaryKey() == primaryKey) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		return (int)getPrimaryKey();
	}

	@Override
	public void resetOriginalValues() {
		HistorySyncVersionModelImpl historySyncVersionModelImpl = this;

		historySyncVersionModelImpl._originalSyncVersion = historySyncVersionModelImpl._syncVersion;

		historySyncVersionModelImpl._columnBitmask = 0;
	}

	@Override
	public CacheModel<HistorySyncVersion> toCacheModel() {
		HistorySyncVersionCacheModel historySyncVersionCacheModel = new HistorySyncVersionCacheModel();

		historySyncVersionCacheModel.id = getId();

		Date requestedDate = getRequestedDate();

		if (requestedDate != null) {
			historySyncVersionCacheModel.requestedDate = requestedDate.getTime();
		}
		else {
			historySyncVersionCacheModel.requestedDate = Long.MIN_VALUE;
		}

		Date timeofPublish = getTimeofPublish();

		if (timeofPublish != null) {
			historySyncVersionCacheModel.timeofPublish = timeofPublish.getTime();
		}
		else {
			historySyncVersionCacheModel.timeofPublish = Long.MIN_VALUE;
		}

		historySyncVersionCacheModel.categoryID = getCategoryID();

		String categoryID = historySyncVersionCacheModel.categoryID;

		if ((categoryID != null) && (categoryID.length() == 0)) {
			historySyncVersionCacheModel.categoryID = null;
		}

		historySyncVersionCacheModel.syncUnit = getSyncUnit();

		String syncUnit = historySyncVersionCacheModel.syncUnit;

		if ((syncUnit != null) && (syncUnit.length() == 0)) {
			historySyncVersionCacheModel.syncUnit = null;
		}

		historySyncVersionCacheModel.syncUser = getSyncUser();

		String syncUser = historySyncVersionCacheModel.syncUser;

		if ((syncUser != null) && (syncUser.length() == 0)) {
			historySyncVersionCacheModel.syncUser = null;
		}

		historySyncVersionCacheModel.syncVersion = getSyncVersion();

		String syncVersion = historySyncVersionCacheModel.syncVersion;

		if ((syncVersion != null) && (syncVersion.length() == 0)) {
			historySyncVersionCacheModel.syncVersion = null;
		}

		Date latestValueDate = getLatestValueDate();

		if (latestValueDate != null) {
			historySyncVersionCacheModel.latestValueDate = latestValueDate.getTime();
		}
		else {
			historySyncVersionCacheModel.latestValueDate = Long.MIN_VALUE;
		}

		return historySyncVersionCacheModel;
	}

	@Override
	public String toString() {
		StringBundler sb = new StringBundler(17);

		sb.append("{id=");
		sb.append(getId());
		sb.append(", requestedDate=");
		sb.append(getRequestedDate());
		sb.append(", timeofPublish=");
		sb.append(getTimeofPublish());
		sb.append(", categoryID=");
		sb.append(getCategoryID());
		sb.append(", syncUnit=");
		sb.append(getSyncUnit());
		sb.append(", syncUser=");
		sb.append(getSyncUser());
		sb.append(", syncVersion=");
		sb.append(getSyncVersion());
		sb.append(", latestValueDate=");
		sb.append(getLatestValueDate());
		sb.append("}");

		return sb.toString();
	}

	@Override
	public String toXmlString() {
		StringBundler sb = new StringBundler(28);

		sb.append("<model><model-name>");
		sb.append("vn.dtt.duongbien.dao.vrcb.model.HistorySyncVersion");
		sb.append("</model-name>");

		sb.append(
			"<column><column-name>id</column-name><column-value><![CDATA[");
		sb.append(getId());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>requestedDate</column-name><column-value><![CDATA[");
		sb.append(getRequestedDate());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>timeofPublish</column-name><column-value><![CDATA[");
		sb.append(getTimeofPublish());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>categoryID</column-name><column-value><![CDATA[");
		sb.append(getCategoryID());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>syncUnit</column-name><column-value><![CDATA[");
		sb.append(getSyncUnit());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>syncUser</column-name><column-value><![CDATA[");
		sb.append(getSyncUser());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>syncVersion</column-name><column-value><![CDATA[");
		sb.append(getSyncVersion());
		sb.append("]]></column-value></column>");
		sb.append(
			"<column><column-name>latestValueDate</column-name><column-value><![CDATA[");
		sb.append(getLatestValueDate());
		sb.append("]]></column-value></column>");

		sb.append("</model>");

		return sb.toString();
	}

	private static ClassLoader _classLoader = HistorySyncVersion.class.getClassLoader();
	private static Class<?>[] _escapedModelInterfaces = new Class[] {
			HistorySyncVersion.class
		};
	private long _id;
	private Date _requestedDate;
	private Date _timeofPublish;
	private String _categoryID;
	private String _syncUnit;
	private String _syncUser;
	private String _syncVersion;
	private String _originalSyncVersion;
	private Date _latestValueDate;
	private long _columnBitmask;
	private HistorySyncVersion _escapedModel;
}